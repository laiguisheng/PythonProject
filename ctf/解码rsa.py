from Crypto.Util.number import long_to_bytes

# --- 1. 手动实现扩展欧几里得算法 ---
# 这个函数会返回 (g, x, y)，满足 a*x + b*y = gcd(a, b) = g
def extended_gcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = extended_gcd(b % a, a)
        return (g, x - (b // a) * y, y)

# --- 2. 题目给出的数据 ---
n = 18267208154653893980929800575964608546551112060956143411146788481114857120669900058071215148330754259183199587716134893778105986201968358406100376342345512412590545862326312484320044823055116142033943458362850270278718584244151524609062347310636764406490718287047988576683476919282477117056849763051051665467813615840185122828290186740529034795710158574396667956675607920800731296078543764909764864850856619769257413619029909960579259374649702287778609279888382580180491456204263799549271278105755147589334837174872786579030819248473004057751877448438120699429171527322600535827093229910390902774515664891068565725223
e1 = 7634992195306653228956179592467268917
e2 = 3886356344544036773491706672427326680305055160386482219239127128946145704243083895553979289948469
c1 = 12014117972714695703479022362757255514479928146538337657834220454241432241366322360595866951648368835732568720998138038985782769578797586473414166774692214030139925844226488683869237059506627069470310782941738184720582798910518062939288730000274353413236556482437369257419061343498031854022450719104113284293996289967815116247662352211337375961188476523457147119314791690751991390054606954167955035815297723851007934474695073742219885132427378597371883394769873844367514754215799455097242488531555003099466552372239867438821036982573427949027339373234763826264749274836372637312458475687873965337550179825971615015754
c2 = 7189579330111704497296456725961610760677174528225883170386504427911504388211958484060970732931639734037266850472428528069665486700617673247813329563057266391223435024378290681605533111097313897220695547879760201705679827074194215694081074980475918559585563883772411744659485300430819326414602019908054382428662300553679826732096674391561631970748837313120661427434246162430997196726152590783161216738381692060599411002029596630967666534348674970169531868126056135056905264159063686109645172962326324875225727766770912404995105458037580346487568600443218248397890945026345534687415161949512179352010041085246411373058

# --- 3. 使用我们自己实现的 extended_gcd 函数求 s 和 t ---
g, s, t = extended_gcd(e1, e2)
assert g == 1, "e1 and e2 are not coprime, attack failed."

# --- 4. 计算明文 m ---
m = (pow(c1, s, n) * pow(c2, t, n)) % n

# --- 5. 将整数 m 转换回字节并移除填充 ---
padded_flag = long_to_bytes(m)
try:
    separator_index = padded_flag.index(b'\x00', 2)
    flag = padded_flag[separator_index + 1:]
    print(f"[+] The flag is: {flag.decode()}")
except ValueError:
    print("[-] Failed to find padding.")
